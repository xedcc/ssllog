import BaseHTTPServer
import fcntl
import hashlib
import os
import random
import re
import shutil
import signal
import SimpleHTTPServer                
import socket
import StringIO
import subprocess
import sys
import threading
import time


class StoppableHttpServer (BaseHTTPServer.HTTPServer):
    """http server that reacts to self.stop flag"""
    arg_in = ''
    retval = ''
    stop = False
    timeout = 1 

class HandlerClass(SimpleHTTPServer.SimpleHTTPRequestHandler, object):
    protocol_version = "HTTP/1.1"
    
    def do_GET(self):
        txid = self.server.arg_in        
        print ('minihttp received ' + self.path + ' request')
        self.path = "/stcppipelog/" + txid +".tar"
        super(HandlerClass, self).do_GET()
        self.server.stop = True
        
    def do_HEAD(self):
        self.server.stop = True
                
    
TESTING = False
if sys.argv[1] == 'testing' if len(sys.argv)>1 else False: TESTING = True
#for ALPHA testing the user may perform unlimited number of sessions
ALPHA_TESTING = True

database = []
#database fields

#'txid':   unique 9-digit id assigned by the escrow for a particular BTC transaction.
#'pubkey': SSH2-formatted RSA public key which the user generates, gives to the escrow, and the escrow adds it to the oracle's authorized keys file. Allows to ssh into the oracle.
#'port':   a random port on the oracle server used for ssh port forwarding. If at the time of banking session this port happens to be occupied, a new random port will be generated, authkeysfile will be updated to use that port and the user will be asked to login again.
#'added':  time when the escrow added this pubkey to the oracle.
#'is_logged_in_now': whether the user is having an active ssh session. Used to prevent multiple ssh sessions by the same user.
#'last_login_time':  last time the user established an ssh session or 0 otherwise.
#'finished_banking'  time when the banking session ended or 0 otherwise. -1 if the user has been banned.
#'hash':   sha256 hash of the tarball of the folder containing logs generated by stcppipe. Hash is taken only after banking session is over.
#'escrow_fetched_tarball': time when the escrow successfully fetched the tarball and confirmed that the tarball's hash matched or 0 otherwise.
#'sshd_ppid': PID of the fork()ed sshd which started stub.py. Used to detect stale sessions after the user disconnects abruptly.

escrow_magic_port = 40123
#user & auditor magic are used in authkeysfile to show that no proper forwarding
#port has been assigned yet
user_magic_port = 123
auditor_magic_port = 456
#list of ports that should not be assigned when choosing a random port
reserved_ports = [escrow_magic_port]

installdir = os.path.dirname(os.path.realpath(__file__))
stcppipe_logdir = os.path.join(installdir, 'stcppipelog')
authorized_keys = os.path.join(installdir, '.ssh', 'authorized_keys')

is_escrow_registered = False
is_escrow_logged_in = False
escrow_last_sshd_ppid = 0

db_lock_path = os.path.join(installdir, 'db.lock')
db_lock_fd = open(db_lock_path, 'w')
ports_lock_path = os.path.join(installdir, 'ports.lock')
ports_lock_fd = open(ports_lock_path, 'w')

def LOCK_DB():
    global db_lock_fd
    fcntl.flock(db_lock_fd, fcntl.LOCK_EX)
    
def UNLOCK_DB():
    global db_lock_fd
    fcntl.flock(db_lock_fd, fcntl.LOCK_UN)
    
def LOCK_PORTS():
    global ports_lock_fd
    fcntl.flock(ports_lock_fd, fcntl.LOCK_EX)
    
def UNLOCK_PORTS():
    global ports_lock_fd
    fcntl.flock(ports_lock_fd, fcntl.LOCK_UN)



#get txid index in the database and 
#the database must be locked by the calling process
def get_txid_index_in_db(txid):
    found_index = -1
    for index,item in enumerate(database):
        if item['txid'] == txid:
            found_index = index
            break
    return found_index

 
def get_database_as_a_string(txid):
    iostr = StringIO.StringIO()
    LOCK_DB()
    if txid != 'escrow-id':
        if get_txid_index_in_db(txid) == -1:
            UNLOCK_DB()
            return 'txid does not exist in database'
    iostr.write(database)
    UNLOCK_DB()
    retval = iostr.getvalue()
    if txid == "escrow-id":
        return retval
    else:
        return retval[ retval.rfind( "{", 0, retval.find("'txid': '"+txid+"'") ) : retval.find( "}", retval.find("'txid': '"+txid+"'") ) ]


def escrow_add_auditor(txid, auditorPubkey, txidToBeAudited):
    #make sure the txid is not in the db already
    LOCK_DB()
    index = get_txid_index_in_db(txid)
    if index >= 0:
        UNLOCK_DB()
        return ('txid already exists')
    #make sure the same pubkey is not added twice
    for item in database:
        if item['pubkey'] == auditorPubkey:
            UNLOCK_DB()
            return ('pubkey already exists')   
    
    database.append({'txid':txid, 'pubkey':auditorPubkey, 'port':auditor_magic_port, 'added': int(time.time()), 'is_logged_in_now':False, 'last_login_time':0, 'finished_banking':0, 'hash': '', 'escrow_fetched_tarball':0, 'sshd_ppid':0})
    UNLOCK_DB()
    akeys_file = open(authorized_keys, 'a')
    fcntl.flock(akeys_file, fcntl.LOCK_EX)
    akeys_file.write('no-pty,no-agent-forwarding,no-user-rc,no-X11-forwarding,permitopen="localhost:'+str(escrow_magic_port)+'",command="/usr/bin/python '+os.path.join(installdir, 'stub.py')+' '+txid+' audit '+txidToBeAudited+'"'+' ssh-rsa '+pubkey+'\n')
    fcntl.flock(akeys_file, fcntl.LOCK_UN)
    akeys_file.close()
    return('success')



def escrow_add_pubkey(txid, pubkey):
    #make sure the txid is not in the db already
    LOCK_DB()
    index = get_txid_index_in_db(txid)
    if index >= 0:
        UNLOCK_DB()
        return ('txid already added')
    #make sure the same pubkey is not added twice
    for item in database:
        if item['pubkey'] == pubkey:
            UNLOCK_DB()
            return ('pubkey already added')   
    
    database.append({'txid':txid, 'pubkey':pubkey, 'port':user_magic_port, 'added': int(time.time()), 'is_logged_in_now':False, 'last_login_time':0, 'finished_banking':0, 'hash': '', 'escrow_fetched_tarball':0, 'sshd_ppid':0})
    UNLOCK_DB()
    akeys_file = open(authorized_keys, 'a')
    fcntl.flock(akeys_file, fcntl.LOCK_EX)
    akeys_file.write('no-pty,no-agent-forwarding,no-user-rc,no-X11-forwarding,permitopen="localhost:'+str(user_magic_port)+'",command="/usr/bin/python '+os.path.join(installdir, 'stub.py')+' '+txid+' login'+'"'+' ssh-rsa '+pubkey+'\n')
    fcntl.flock(akeys_file, fcntl.LOCK_UN)
    akeys_file.close()
    return('success')
                            
#used by escrow when issuing get_tarball command
def check_tarball_availability(txid):
    LOCK_DB()
    index = get_txid_index_in_db(txid)
    if index < 0:
        UNLOCK_DB()
        return ('does not exist')
    has_finishes_session = database[index]['finished_banking']
    is_sent_to_escrow = database[index]['escrow_fetched_tarball']
    UNLOCK_DB()
    
    if not has_finishes_session:
        return ('user has not yet finished their banking session')
    if is_sent_to_escrow == True:
        return ('tarball already sent to escrow')
    else:    
        return ('available')


def cleanup_and_exit(conn,  msg='', txid=0):
    if txid == 'escrow-id':
        global is_escrow_logged_in
        is_escrow_logged_in = False
    elif txid !=0:
        LOCK_DB()        
        index = get_txid_index_in_db(txid)
        if index < 0:
            UNLOCK_DB()            
            print('Session finished. Transaction ID not found in database')
            conn.send('Session finished. Transaction ID not found in database')
            time.sleep(1)
            conn.close()
            return
        is_logged_in = database[index]['is_logged_in_now']
        database[index]['is_logged_in_now'] = False
        UNLOCK_DB()
        if is_logged_in == False:
            print('Session finished. Internal error. User was already logged out')
            conn.send('Session finished. Internal error. User was already logged out')
            time.sleep(1)
            conn.close()
            return
    print('Session finished. ' + msg)
    conn.send('Session finished. ' + msg)
    time.sleep(1)
    conn.close()
    return


#change the forwarding port in authkeysfile for user or auditor
def update_authkeysfile_with_port(txid, newport):
    #we use 2 file descriptors to open the file for reading and writing. The lock is held on the reading file descriptor
    fd_read = open(authorized_keys, 'r')
    fcntl.flock(fd_read, fcntl.LOCK_EX)
    filedata = fd_read.read()
    lines = filedata.split('\n')
    is_found_in_authkeys = False
    for index,line in enumerate(lines):
        if line.count(txid+' login') == 1or line.count(txid+'audit') == 1:
            line = re.sub('permitopen="localhost:.*"', 'permitopen="localhost:'+str(newport)+'\"', line)
            lines.pop(index)
            lines.insert(index, line)
            is_found_in_authkeys = True
            break
    if not is_found_in_authkeys:
        fcntl.flock(fd_read, fcntl.LOCK_UN)
        fd_read.close()
        return('txid not found in authkeysfile')
    fd_write = open(authorized_keys, 'w')
    for line in lines:
        fd_write.write(line+'\n')  
    fd_write.close()
    fcntl.flock(fd_read, fcntl.LOCK_UN)
    fd_read.close()
    return ('success')


#gets a new port from a pool of free system ports
def get_new_port():
    LOCK_PORTS()
    while True:
        newport = random.randint(1025,65535)
        if not newport in reserved_ports: break
    reserved_ports.append(newport)
    UNLOCK_PORTS()
    return newport

def release_port(port):
    LOCK_PORTS()
    try:
        reserved_ports.remove(port)
    except:
        #it is too cumbersome to notify the calling thread of the exception
        UNLOCK_PORTS()
        return
    UNLOCK_PORTS()

              
def user_thread(conn, txid, sshd_ppid):
    LOCK_DB()
    index = get_txid_index_in_db(txid)
    if index < 0:
        UNLOCK_DB()
        cleanup_and_exit(conn, 'Transaction ID not found in database')
        return
    is_logged_in = database[index]['is_logged_in_now']
    prev_sshd_ppid = database[index]['sshd_ppid']
    if is_logged_in:
        #check for a stale session from previous login
        try:
            os.kill(prev_sshd_ppid, 0)
            #we get here if there was no exception
            UNLOCK_DB()
            cleanup_and_exit(conn, 'This user is already logged in')
            return
        except OSError:
            #The PID is no longer running, i.e. not a stale session, leave is_logged_in in True and move on
            pass
    
    finished_banking = database[index]['finished_banking']          
    database[index]['is_logged_in_now'] = True
    database[index]['sshd_ppid'] = int(sshd_ppid)
    prev_login_time = database[index]['last_login_time']
    database[index]['last_login_time'] = int(time.time())
    #Copy the vars which we'll need later, so we don't have to lock db again later
    port = database[index]['port']
    UNLOCK_DB()
    
    #else if not the very first login
    if not ALPHA_TESTING and finished_banking != 0:
        #if the user has finished the banking session, his only business here is to get a copy of his db entry
        db_str = get_database_as_a_string(txid)
        conn.send('database ' + db_str)
        #allow stub to process socket data before sending the "finished" message
        time.sleep(3)
        cleanup_and_exit(conn, 'Sent database to user', txid)
        return
    
    if int(time.time()) - prev_login_time > 60:
        #this is either user's very first login or a non-first login and there was a failure to get the tracefile
        #on the previous attempt (timeout of 60 secs expired)
        #Generate a new forwarding port and tell the user to reconnect to this new port
        newport = get_new_port()
        conn.send('Please reconnect and use the following port for forwarding: '+str(newport))
        #wait for an ACK and disconnect
        rv = receive_ACK(conn)
        if rv != 'success':
            #the user didn't send back an ACK, assume there was a network problem and release the port
            release_port(newport)
            cleanup_and_exit(conn, rv, invoking_txid)
            return
        #else ACK received
        rv = update_authkeysfile_with_port(txid, newport)
        if rv != 'success':
            release_port(newport)
            cleanup_and_exit(conn, rv, invoking_txid)
            return
        LOCK_DB()
        index = get_txid_index_in_db(txid)
        if index < 0:
            UNLOCK_DB()
            cleanup_and_exit(conn, 'Transaction ID not found in database')
            return
        #else txid index found
        database[index]['port'] = newport
        UNLOCK_DB()
        cleanup_and_exit(conn, 'Authkeys file entry successfully changed', txid)
        return
    
    #else if not the first login, then setup to perform banking audit  
    if not os.path.isdir(stcppipe_logdir): 
        #the very first session for this oracle machine
        os.mkdir(stcppipe_logdir)
    logdir = os.path.join(stcppipe_logdir, txid)
    if os.path.isdir(logdir): 
        #may happen if user aborted the previous session half-way and is now retrying
        shutil.rmtree(logdir)
    os.mkdir(logdir)
    start_time = int(time.time())
    stcppipe_proc = subprocess.Popen([os.path.join(installdir, 'stcppipe'), '-d', logdir, '-b', '127.0.0.1', '3128', str(port)])
    time.sleep(1)
    if stcppipe_proc.poll() == 1:
        #if stcppipe returns with returncode 1 , it means that there was some error.
        #This definitely can't be "address in use" because we reserve forwarding ports in advance, so that 
        #two threads cannot claim the same port
        release_port(port)
        cleanup_and_exit(conn, 'There was an unknown error in stcppipe', txid)
        return
    conn.send('Tunnel ready')
        
    #wait for sslkey from the user
    last_dos_check = start_time
    conn.settimeout(1 if TESTING else 10)
    while 1:
        try:
            msg_in = None            
            msg_in = conn.recv(1024)
        except:
            #timeout reached
            pass
        current_time = int(time.time())
        if current_time-start_time > 1200:
            #there was no sslkey for 20 minutes, wrapping up
            os.kill(stcppipe_proc.pid, signal.SIGTERM)
            time.sleep(3)
            if os.path.isdir(logdir): shutil.rmtree(logdir)
            release_port(port)
            cleanup_and_exit(conn, 'Time limit expired. Connection closed', txid)
            return
        
        #Anti DOS measure. Every minute make sure the user is not overwhelming the logdir with data or new files(generated on every new  SSL connection). Limits: 1000 files or 50MB of data
        if current_time-last_dos_check > 60:
            last_dos_check = current_time
            if os.path.isdir(logdir):
                filelist = os.listdir(logdir)
                if len(filelist) > 1000 or sum([os.path.getsize(os.path.join(logdir,f)) for f in filelist]) > 50000000:
                    ban_user(txid)
                    os.kill(stcppipe_proc.pid, signal.SIGTERM)
                    time.sleep(3)
                    if os.path.isdir(logdir): shutil.rmtree(logdir)
                    release_port(port)
                    cleanup_and_exit(conn, 'You have been banned. Contact escrow for details')
                    return
        
        if msg_in: 
            if msg_in.startswith(txid+'-cmd sslkey'):
                os.kill(stcppipe_proc.pid, signal.SIGTERM)
                time.sleep(3)
                
                if not ALPHA_TESTING:
                    sslkey = msg_in[len(txid+'-cmd sslkey '):]
                    if len(sslkey) > 180:
                        shutil.rmtree(logdir)
                        cleanup_and_exit(conn, 'Wrong sslkey length', txid)
                        return                       
                    sslkey_fd = open(os.path.join(logdir,'sslkey'), 'w')
                    sslkey_fd.write(sslkey+'\n')
                    sslkey_fd.close()
                
                release_port(port)
                finish_time = int(time.time())                
                tar_path = os.path.join(stcppipe_logdir, txid+'.tar')
                subprocess.call(['tar', 'cf', tar_path, '-C', logdir, '.'])
                shutil.rmtree(logdir)                
                output = subprocess.check_output(['sha256sum', tar_path])
                sha_hash = output.split()[0]
                
                LOCK_DB()
                index = get_txid_index_in_db(txid)
                if index < 0:
                    UNLOCK_DB()
                    cleanup_and_exit(conn, 'Transaction ID not found in database')
                    return
                database[index]['finished_banking'] = finish_time
                database[index]['hash'] = sha_hash
                UNLOCK_DB()
                
                if ALPHA_TESTING:
                    #ALPHA ONLY: expect the user to request the tarball
                    #setup a mini http server and listen for GET requests
                    print ('Starting mini http server')
                    try:
                        #serve files relative to root dir
                        os.chdir(installdir)
                        httpd = StoppableHttpServer(('127.0.0.1', port), HandlerClass)
                        httpd.arg_in = txid
                    except Exception, e:
                        os.remove(os.path.join(stcppipe_logdir, txid+'.tar'))                    
                        cleanup_and_exit(conn, 'Error starting mini http server', txid)
                        return
                    starttime = time.time()
                    while not httpd.stop:
                            httpd.handle_request()
                            #we get here when timeout=1 triggers
                            if time.time() - starttime > 60:
                                os.remove(os.path.join(stcppipe_logdir, txid+'.tar'))                            
                                cleanup_and_exit(conn, 'Tarball not requested in 1 mins', txid)
                                return
                    #now wait for user to send exit success or exit failure
                    continue                        
                #else if not ALPHA
                cleanup_and_exit(conn, 'Session ended successfully', txid)
                return
            
            if not ALPHA_TESTING:
                if msg_in == txid+'-cmd exit':
                    os.kill(stcppipe_proc.pid, signal.SIGTERM)
                    time.sleep(3)
                    if os.path.isdir(logdir): shutil.rmtree(logdir)
                    release_port(port)
                    cleanup_and_exit(conn, 'User initiated shutdown', txid)
                    return
            
            if ALPHA_TESTING:
                if msg_in.startswith(txid+'-cmd exit'):
                    result = None
                    result_in_list = msg_in[len(txid+'-cmd exit'):].split()
                    if len(result_in_list) == 0:
                        #user sent only half the message - "exit" without "success"/"failure"
                        os.kill(stcppipe_proc.pid, signal.SIGTERM)                    
                        if os.path.isdir(logdir): shutil.rmtree(logdir)                    
                        cleanup_and_exit(conn, 'User terminated abruptly', txid)
                        return  
                    else:
                        result = result_in_list[0]
                    dbresult = 1 if (result == 'success') else -1
                    LOCK_DB
                    index = get_txid_index_in_db(txid)
                    database[index]['escrow_fetched_tarball'] = dbresult
                    UNLOCK_DB
                    cleanup_and_exit(conn, 'User initiated shutdown', txid)
                    return                
                                
            else:
                os.kill(stcppipe_proc.pid, signal.SIGTERM)
                time.sleep(3)
                if os.path.isdir(logdir): shutil.rmtree(logdir)
                release_port(port)
                cleanup_and_exit(conn, 'Unknown command received. Expected "sslkey or exit"', txid)
                return
    

#wait for client to send ACK and return success
def receive_ACK(conn):
    conn.settimeout(1)
    starttime = time.time()
    msg_in = None
    while 1:
        try:
            #this will throw an exception every second
            msg_in = conn.recv(1024)
        except:
            #timeout reached
            pass
        current_time = int(time.time())
        if current_time-start_time > 10:
            #the user didn't send back an ACK, assume there was a network problem
            return ('Failed to receive ACK in due time')
        if msg_in:
            if msg_in != 'ACK':
                return ( 'Expected \'ACK\' but instead received '+msg_in)
            else:
                #ACK received
                return ('success')


#This thread gives auditor one minute to fetch the tarball
#The auditor has to login like ssh -R 22222:localhost:11111 and then do wget localhost:11111/somefile
#where 11111 is an arbitrary local port and 22222 was assigned to auditor by sshd on previous login

def auditor_thread(conn, invoking_txid, txid_of_tracefile, ppid):
    LOCK_DB()
    index = get_txid_index_in_db(invoking_txid)
    if index < 0:
        UNLOCK_DB()
        cleanup_and_exit (conn, 'Internal error. Auditor\'s txid does not exist in the database')
        return
    index_to_be_audited = get_txid_index_in_db(txid_of_tracefile)
    if index_to_be_audited < 0:
        UNLOCK_DB()
        cleanup_and_exit (conn, 'Internal error. The txid which is supposed to be audited by the Auditor does not exist in the database')
        return
    is_logged_in = database[index]['is_logged_in_now']
    if is_logged_in:
        UNLOCK_DB()
        cleanup_and_exit (conn, 'Auditor\'s txid is already logged in')
        return
    #else:
    database[index]['is_logged_in_now'] = True
    time_finished= database[index]['finished_banking']
    prev_login_time = database[index]['last_login_time']
    database[index]['last_login_time'] = int(time.time())
    port = database[index]['port']
    UNLOCK_DB()
    
    db_str = get_database_as_a_string(txid_of_tracefile)
    conn.send('database ' + db_str)
    #allow stub.py to process socket data before sending next messages
    time.sleep(3)
    
    if time_finished != 0:
     #the auditor already received the tracefile before. There's nothing more for him to do here.
        cleanup_and_exit(conn, 'Auditor has already received the tracefile', invoking_txid)
        return
    #else prepare to serve the tracefile
    #don't complicate the code by checking for a stale session like we do in user_thread because if the auditor lost connection
    #while trying to fetch the tarball, he can simply wait for 1 minute and try again
    #The oracle will automatically terminate the auditor's ssh sessions after 1 minute
    if int(time.time()) - prev_login_time > 60 :
        #this is either auditor's very first login or a non-first login and there was a failure to get the tracefile
        #on the previous attempt (timeout of 60 secs expired)
        #Generate a new forwarding port and tell the auditor to reconnect to this new port
        newport = get_new_port()
        conn.send('Please reconnect and use the following port for forwarding: '+str(newport))
        #wait for an ACK and disconnect
        rv = receive_ACK(conn)
        if rv != 'success':
            #the user didn't send back an ACK, assume there was a network problem and release the port
            release_port(newport)
            cleanup_and_exit(conn, rv, invoking_txid)
            return
        #else ACK received  
        rv = update_authkeysfile_with_port(invoking_txid, newport)
        if rv != 'success':
            release_port(newport)
            cleanup_and_exit(conn, rv, invoking_txid)
            return
        LOCK_DB()
        index = get_txid_index_in_db(invoking_txid)
        if index < 0:
            UNLOCK_DB()
            cleanup_and_exit(conn, 'Transaction ID not found in database')
            return
        #else txid index found
        database[index]['port'] = newport
        UNLOCK_DB()
        cleanup_and_exit(conn, 'Authkeys file entry successfully changed', invoking_txid)
        return
    
    #else if less than 1 minutes elapsed since last login (when the auditor received the forwarding port)
    #serve the tracefile for 60 seconds
    print ('Starting mini http server to serve the tracefile for ' + txid_of_tracefile)
    try:
        #serve files relative to root dir
        os.chdir(installdir)
        httpd = StoppableHttpServer(('127.0.0.1', port), HandlerClass)
        httpd.arg_in = txid_of_tracefile
    except Exception, e:
        release_port(newport)
        cleanup_and_exit(conn, 'Http error occured', invoking_txid)
        return
    starttime = time.time()
    while not httpd.stop:
            httpd.handle_request()
            #we get here when timeout=1 triggers
            if time.time() - starttime > 60:
                release_port(newport)
                cleanup_and_exit (conn, 'Tarball not requested in 1 min', invoking_txid)
                return
    #we get here when tarball has been successfully fetched.
    #Receive ACK and change the tracefile owner's data and remove the tracefile
    release_port(newport)
    rv = receive_ACK(conn)
    if rv != 'success':
        #the user didn't send back an ACK, assume there was a network problem
        cleanup_and_exit(conn, rv, invoking_txid)
        return
    LOCK_DB()
    index = get_txid_index_in_db(txid_of_tracefile)
    if index < 0:
        UNLOCK_DB()
        cleanup_and_exit (conn, 'tracefile\'s txid does not exist even though it existed just a minute ago', invoking_txid)
        return
    database[index]['finished_banking'] = int(time.time())
    UNLOCK_DB()
    os.remove(os.path.join(stcppipe_logdir, txid_of_tracefile+'.tar'))
    cleanup_and_exit(conn, 'OK', invoking_txid)
    return


def escrow_thread(conn, sshd_ppid):
    global is_escrow_registered
    global is_escrow_logged_in
    global escrow_last_sshd_ppid
    
    if is_escrow_logged_in:
        #check for a stale session from the previous login
        try:
            os.kill(escrow_last_sshd_ppid, signal.SIGTERM)
            #if we get here, there was no exception, meaning that escrow was indeed still logged in
            conn.send('Escrow had an active session which was terminated')            
        except OSError:
            #the PID was not found, i.e. no stale session detected. Leave the logged_in flag and move on
            pass     
    
    is_escrow_logged_in = True
    escrow_last_sshd_ppid = int(sshd_ppid)
    conn.settimeout(1)
    
    while 1:
        #escrow isn't allowed to make more than one request per minute. Anti DOS measure.
        time.sleep(1 if TESTING or ALPHA_TESTING else 60)
        try:
            args = conn.recv(1024)
        except:
            #timeout triggered
            continue
        arglist = args.split()
        if len(arglist) < 2:
            cleanup_and_exit(conn, 'Too few arguments', 'escrow-id')
            return
        magic, cmd, paralist = arglist[0], arglist[1], arglist[2:]
        if not magic == 'escrow-id-cmd':
            cleanup_and_exit(conn, 'Internal error. Wrong magic string', 'escrow-id')
            return
        if not is_escrow_registered and not cmd == 'register_escrow':
            cleanup_and_exit(conn, 'You must register escrow first', 'escrow-id')
            return
        if cmd == 'register_escrow':
            #This is the very first command that escrow must send after installing this oracle
            #format: register_escrow pubkey
            if len(paralist) != 1:
                cleanup_and_exit(conn, 'Invalid amount of parameters', 'escrow-id')
                return
            if is_escrow_registered:
                cleanup_and_exit(conn, 'Escrow already registered', 'escrow-id')
                return
            pubkey  = paralist[0]
            if (len(pubkey) > 1000):
                cleanup_and_exit(conn, 'Faulty data for registering escrow', 'escrow-id')
                return
            
            akeys_file = open(authorized_keys, 'w')
            fcntl.flock(akeys_file, fcntl.LOCK_EX)            
            akeys_file.write('no-pty,no-agent-forwarding,no-user-rc,no-X11-forwarding,permitopen="localhost:'+str(escrow_magic_port)+'",command="/usr/bin/python '+os.path.join(installdir, 'stub.py') + ' escrow-id login" ssh-rsa '+pubkey+'\n')
            fcntl.flock(akeys_file, fcntl.LOCK_UN)
            akeys_file.close()
            
            is_escrow_registered = True
            conn.send('Escrow successfully registered')
            continue    
        
        
        if cmd == 'add_pubkey':
            #format: add_pubkey pubkey tx-id 
            if len(paralist) != 2:
                cleanup_and_exit(conn, 'Invalid amount of parameters', 'escrow-id')
                return
            pubkey, txid = paralist
            if (len(txid) != 9) or (len(pubkey) > 1000) :
                cleanup_and_exit(conn, 'Faulty data for adding a pubkey', 'escrow-id')
                return
            retval = escrow_add_pubkey(txid, pubkey)
            if retval != 'success':
                cleanup_and_exit(conn, retval, 'escrow-id')
                return
            else:
                conn.send('Public key successfully added to database')
                continue
        
        if cmd == 'add_auditor':
            #OT feature. Add an auditor who can get a status of only one specific transaction and fetch its tracefile
            #format: add_auditor auditor_pubkey tx-id txid_to_be_audited
            if len(paralist) != 3:
                cleanup_and_exit(conn, 'Invalid amount of parameters', 'escrow-id')
                return
            auditorPubkey, txid, txidToBeAudited = paralist
            if len(auditorPubkey) > 1000 or len(txidToBeAudited) > 9 or len(txid) > 9:
                cleanup_and_exit(conn, 'Faulty data for adding an auditor pubkey', 'escrow-id')
                return
            retval = escrow_add_auditor(txid, auditorPubkey, txidToBeAudited)
            if retval != 'success':
                cleanup_and_exit(conn, retval, 'escrow-id')
                return
            else:
                conn.send('Auditor\'s public key successfully added to database')
                continue
                 
                       
        if cmd == 'get_tarball':
            #format: get_tarball txid
            if len(paralist) != 1:
                cleanup_and_exit(conn, 'Invalid amount of parameters', 'escrow-id')
                return
            txid = paralist[0]
            rv = check_tarball_availability(txid)
            if rv != 'available':
                cleanup_and_exit(conn, rv, 'escrow-id')
                return
            
            conn.send ('Starting mini http server. I will not accept any commands for 1 minute or until the tarball is fetched')
            try:
                #serve files relative to root dir
                os.chdir(installdir)
                httpd = StoppableHttpServer(('127.0.0.1', escrow_magic_port), HandlerClass)
                httpd.arg_in = txid
            except Exception, e:
                cleanup_and_exit(conn, 'Error starting mini http server', 'escrow-id')
                return
            starttime = time.time()
            while not httpd.stop:
                httpd.handle_request()
                #we get here when timeout=1 triggers
                if time.time() - starttime > 60:
                    cleanup_and_exit(conn, 'Tarball not requested in 1 min', 'escrow-id')
                    return
            #we get here after the tracefile was successfully sent
            #change the tracefile owner's data and remove the tracefile
            LOCK_DB()
            index = get_txid_index_in_db(txid)
            if index < 0:
                UNLOCK_DB()
                cleanup_and_exit (conn, 'tracefile\'s txid does not exist even though it existed just a minute ago', 'escrow-id')
                return
            database[index]['escrow_fetched_tarball'] = int(time.time())
            UNLOCK_DB()
            os.remove(os.path.join(stcppipe_logdir, txid+'.tar'))
            conn.send('Tarball has been fetched, accepting commands now')
            continue
               
                
        if cmd == 'get_database':
            if len(paralist) != 0:
                cleanup_and_exit(conn, 'Invalid amount of parameters', 'escrow-id')
                return
            db_str = get_database_as_a_string("escrow-id")
            conn.send('database ' + db_str)
            continue
        
        
        if cmd == 'exit':
            cleanup_and_exit(conn, 'Escrow initiated disconnect', 'escrow-id')
            return
                   
        else:
            cleanup_and_exit(conn, 'Unrecognized command', 'escrow-id')
            return

#remove txid record from authorizedkeys file
#Leave it in the database as proof that the user was once registered and later was banned
def ban_user(txid):
    if not txid:
        print 'internal error. Empty txid'
        return
    fd_read = open(authorized_keys, 'r')
    fcntl.flock(fd_read, fcntl.LOCK_EX)
    filedata = fd_read.read()
    lines = filedata.split('\n')
    is_found_in_authkeys = False
    for index,line in enumerate(lines):
        if line.count(txid) != 0:
            lines.pop(index)
            is_found_in_authkeys = True
            break
    if not is_found_in_authkeys:
        print ('Internal error. The txid to be banned was not found in authorized keys file')
        fcntl.flock(fd_read, fcntl.LOCK_UN)
        fd_read.close()
        return
    fd_write = open(authorized_keys, 'w')
    for line in lines:
        fd_write.write(line+'\n')
    fd_write.close()
    fcntl.flock(fd_read, fcntl.LOCK_UN)
    fd_read.close()
    
    #NB escrow is never in the database, so we never ban him
    if txid != 'escrow-id':
        LOCK_DB()
        index = get_txid_index_in_db(txid)
        if index < 0:
            UNLOCK_DB()
            print ('Internal error. txid to be banned doesn\'t exist in database')
            return
        #else if txid exists
        database[index]['finished_banking'] = -1
        UNLOCK_DB()
        

                

if __name__ == "__main__":
    
    #on first run, check stcppipe.zip's hash and compile it
    #stcppipe by Luigi Auriemma http://aluigi.altervista.org/mytoolz/stcppipe.zip v.0.4.8b
    sp_fd = open(os.path.join(installdir,"stcppipe.zip"), 'r')
    sp_bin = sp_fd.read()
    sp_fd.close()
    if (hashlib.sha256(sp_bin).hexdigest() != "3fe9e52633d923733841f7d20d1c447f0ec2e85557f68bac3f25ec2824b724e8"):
        print ('Wrong stcppipe.zip hash')
        exit(1)    
    
    oracle_socket = os.path.join(installdir, 'oracle-socket')
    s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    if os.path.exists(oracle_socket): os.unlink(oracle_socket)
    s.bind(oracle_socket)
    #/proc/sys/net/core/somaxconn is 128 on Linux, We need to able to process this many new connection in case of DOS
    s.listen(128)
    #timeout is needed because if the socket is blocking, we won't be able to pause this script under debugger
    s.settimeout(1)
    
    while 1:
        try:
            #timeout triggered, sleep so that (when debugging) the Ctrl+C could stop the script
            time.sleep(0.2)
        except:
            #Ctrl+C has been pressed
            exit(0)
        try:
            conn, addr = s.accept()
        except:
            continue
        args = conn.recv(1024)
        arglist = args.split()
        if len(arglist) < 3:
            cleanup_and_exit(conn, 'Internal error. Did not receive at least 3 arguments')
            continue
        # parent PID (PID of sshd fork) is passed into a thread, so that when the thread terminates, we could
        #kill the PPID and prevent any possible memory leaks
        ppid = arglist.pop(-1)
        action = arglist[1]
             
                
        if action == 'login': 
            if len(arglist) != 2:
                cleanup_and_exit(conn, 'Internal error. 2 arguments expected for  \'login\' ')
                continue
            txid_to_login = arglist[0]
            if txid_to_login == 'escrow-id':
                thread = threading.Thread(target= escrow_thread, args=(conn, ppid))
                thread.daemon = True
                thread.start()
                continue
            else:
                thread = threading.Thread(target= user_thread, args=(conn, txid_to_login, ppid))
                thread.daemon = True
                thread.start()
                continue
            
            
        elif action == 'audit':
            #OpenTransaction's feature. Auditor's connection. Return just one DB entry
            #and start an http  server to serve the tracefile
            if len(arglist) != 3:
                cleanup_and_exit(conn, 'Internal error. 3 arguments expected for  \'audit\' ')
                continue
            invoking_txid, txid_to_audit = arglist[0], arglist[2]
            thread = threading.Thread(target= auditor_thread, args=(conn, invoking_txid, txid_to_fetch, ppid))
            thread.daemon = True
            thread.start()
            continue
            
                                    
        elif action == 'ban':
            if len(arglist) != 2:
                cleanup_and_exit(conn, 'Internal error. 2 arguments expected for  \'ban\' ')
                continue
            ban_user(arglist[2])
            continue

            